
RRT.init(qinit) <- goal state (current car location)
    for k = 1 to K (or time, choose whats best)
        qRand = RandConf() <- rand valid state , done
        qnear = Nearest_Vertex(qRand, Tree) <- pick the nearest point in the tree to expand it later. partially done
        qNew = NewConf(qRand, qNear, Tree) <- a new state between qRand and qNear , linearlly interpolated
        Check if its possible to reach the new node before adding it
        if yes, add vertex(qNew) and add edge(qNear, qNew)

    return tree


	_inNbr = 0;

	/* RRT* - Still in consideration. Dont know if its worth it or not.
	for (size_t n = 0; n < myrrt->getPool().size() - 1; n++)
	{
		int edgeDif = Dist::eucl(step, *myrrt->getAt(n)->getPos());
		if (edgeDif <= NBR_RADIUS)
			{
				_inNbr++;
				cout << myrrt->getAt(n)->getEdgeCost() << "  ";
			}
	}
		cout << endl << _inNbr << endl;
		cout << "________" << endl;
		*/

in line 273~ rrtcar cpp. I dont know if i should do RRT* do to edge length restriction. A rewired edge may be too long for efficient traversal.

eu sei que ele segue o "plan" deliniado pelo k1999
a ideia agora era fazer com q, em vez de ele seguir o plan, fizesse um offset aos nodos mais proximos do k1999 de modo a q ficasse igual ao RRT naquele troÃ§o. 

foreach x in pathVec:
	foreach n in plan:
		dist = euclDist(x,n)
		minIndex = n.index
		if dist < minDist 
			minDist = dist

	plan[n].pos = x.pos	