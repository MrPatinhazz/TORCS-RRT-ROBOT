
RRT.init(qinit) <- goal state (current car location)
    for k = 1 to K (or time, choose whats best)
        qRand = RandConf() <- rand valid state , done
        qnear = Nearest_Vertex(qRand, Tree) <- pick the nearest point in the tree to expand it later. partially done
        qNew = NewConf(qRand, qNear, Tree) <- a new state between qRand and qNear , linearlly interpolated
        Check if its possible to reach the new node before adding it
        if yes, add vertex(qNew) and add edge(qNear, qNew)

    return tree


	_inNbr = 0;

	/* RRT* - Still in consideration. Dont know if its worth it or not.
	for (size_t n = 0; n < myrrt->getPool().size() - 1; n++)
	{
		int edgeDif = Dist::eucl(step, *myrrt->getAt(n)->getPos());
		if (edgeDif <= NBR_RADIUS)
			{
				_inNbr++;
				cout << myrrt->getAt(n)->getEdgeCost() << "  ";
			}
	}
		cout << endl << _inNbr << endl;
		cout << "________" << endl;
		*/

in line 273~ rrtcar cpp. I dont know if i should do RRT* do to edge length restriction. A rewired edge may be too long for efficient traversal.

Ideia inicial: tenho q definir , desenhar e por o carro a seguir o trilho q eu definir. Ja tenho o vector de apontadores para os estados q vao compor o trilho. o inicio por agora e a root da statePool. fica facil definir um goal "random" e fazer backtrack ate a root. depois de construir a arvore toda 
	setGoal(statepool[random])
	if(parent != null)
		copy this -> pathVec
		currentState -> parent
	else
		stop 

pra ele seguir preciso de investigar ainda. possivelmente alguma cena a ver com o PID.	