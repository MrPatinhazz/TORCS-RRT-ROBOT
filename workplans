
	_inNbr = 0;

	/* RRT* - Still in consideration. Dont know if its worth it or not.
	for (size_t n = 0; n < myrrt->getPool().size() - 1; n++)
	{
		int edgeDif = Dist::eucl(step, *myrrt->getAt(n)->getPos());
		if (edgeDif <= NBR_RADIUS)
			{
				_inNbr++;
				cout << myrrt->getAt(n)->getEdgeCost() << "  ";
			}
	}
		cout << endl << _inNbr << endl;
		cout << "________" << endl;
		*/

//////////////////////////////////////////////////
com 1 adversario apenas é simples, mas com varios adversarios preciso de detetar dinamicamente qual o carro mais proximo a ultrapassar. senao me engano o pathfinder faz isso.

em seguida, preciso de identificar um ponto x segmentos à frente desse adversario e ai fazer o backtracking para a minha atual posicao
